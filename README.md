# Сделать папку репозиторием — **git init**

Например, создай папку first-project и сделай её Git-репозиторием: перейди в неё с помощью команды cd и выполните git init.

```
$ cd ~/dev/first-project  *перешли в нужную папку*

$ git init  *создали репозиторий*
```

# Проверь состояние репозитория — **git status**

После инициализации репозитория first-project запусти команду git status (от англ. status — «статус», «состояние») — она показывает текущее состояние репозитория. 

```
$ git status
```

# Подготовить файлы к сохранению — git add

Добавь в репозиторий два файла. Например, файл todo.txt, в котором будет список дел, и readme.txt для информации о проекте.

*Для этого создай файлы todo.txt и readme.txt в папке first-project и запусти git status, чтобы посмотреть, что изменилось*.

```
$ touch todo.txt
$ touch readme.txt
# создали файлы todo.txt и readme.txt

$ git status *проверили статус*

```

# Выполнить коммит — git commit

Сделать коммит можно командой git commit c ключом -m (от англ. message — «сообщение»), который присваивает коммиту сообщение.
Обычно в таком сообщении поясняется, в чём именно состояли изменения. Это как заметки на полях: благодаря им проще читать и понимать текст. Сообщение коммита выполняет те же функции — улучшает понимание и упрощает навигацию. Оно пишется после ключа -m в кавычках.

Например, перейди в папку first-project и выполни коммит со следующим комментарием.
```
$ git commit -m ‘Мой первый коммит!’ 
```

***Итого твои основные действия***:

1. Создать файлы в репозитории через команду $ touch.
2. Добавить их в репозитории через команду $ git add file.txt
3. Сделать коммит через команду $ git commit

Теперь переходим к самому важному этапу.

# Связываем локальный и удалённый репозитории.

1. Перейди на страницу удалённого репозитория, выбери тип SSH и скопируй URL. Кнопка справа позволит сделать это мгновенно.
2. Откройте консоль, перейдите в каталог локального репозитория и введите команду git remote add (от англ. remote — «удалённый» и add — «добавить»).

```
$ cd ~/dev/first-project
$ git remote add origin git@github.com:%ИМЯ_АККАУНТА%/first-project
```
И давай убедимся, что репозитории связаны:

```
$ git remote -v
origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (fetch)
origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (push)
```

**Отлично**: мы связали локальный репозиторий с удалённым. Осталось убедиться, что всё работает, с помощью следующей команды.
```
$ git remote -v
```
---
Ну и наконец давай отправим изменения на удалённый репозиторий через команду git push.

# Синхронизируем локальный и удалённый репозитории

Если помнишь шаги выше, их было три, последний и ключевой шаг - это:
*Отправить изменения на удалённый репозиторий — **git push***

```
$ git push -u origin main *Если команда приведёт к ошибке, попробуйте заменить main на master*.
```

Вуаля! Обнови страницу в Git Hub и убедись, что изменения подтянулись.

Ну и продолжим...

# Xеш — основной идентификатор коммита

Вот основные постулаты по этой теме:

1. Таблица соответствия хеш → информация о коммите хранится в папке .git.
Git хранит всю свою служебную информацию в этой папке, в том числе и таблицу, в которой можно найти коммит по хешу.
2. Основной идентификатор коммита — это его хеш.
3. Если посчитать хеш одного и того же файла (одним и тем же алгоритмом) на двух разных компьютерах, то результат будет гарантированно одинаковым.
Хеш-алгоритм выдаст одно и то же значение для одного набора данных — это не зависит от того, где и как он был запущен.

# Исследуем лог
Для того, чтобы вызвать лог необходимо воспользоваться следующими командами:

1. Вывод полного лога с элементами через $ git log:
* Cтрока из цифр и латинских букв после слова commit — это хеш коммита;
* Author — имя автора и его электронная почта;
* Date — дата и время создания коммита;
* В конце находится сообщение коммита.

2. Вывод сокращенного лога с элементами через $ git log --oneline:
В терминале появятся только первые несколько символов хеша каждого коммита и их комментарии.

**Обрати внимание: если выход из просмотра логов не произошёл автоматически, нажмите клавишу Q (от англ. Quit — «выйти») в английской раскладке клавиатуры**.


# Файл HEAD

Файл HEAD (англ. «голова», «головной») — один из служебных файлов папки .git. Он указывает на коммит, который сделан последним (то есть на самый новый).
В этом можно убедиться с помощью терминала. Перейди в папку .git командой cd. Посмотри содержимое файла HEAD командой cat.

```
 pwd # посмотрели, где мы
/Users/user/dev/first-project

$ cd .git/
$ ls # посмотрели, какие есть файлы
COMMIT_EDITMSG  ORIG_HEAD  description  index  logs/     refs/
HEAD            config     hooks/       info/  objects/

$ cat HEAD # команда cat показывает содержимое файла
ref: refs/heads/main # в файле вот такая ссылка 
```

Внутри HEAD — ссылка на служебный файл: refs/heads/master (или refs/heads/main в зависимости от названия ветки). Если заглянуть в этот файл, можно увидеть хеш последнего коммита.

```
$ cat refs/heads/master # взяли ссылку из файла HEAD
# внутри хеш
e007f5035f113f9abca78fe2149c593959da5eb7

$ git log 
# сверяем с хешем последнего коммита
commit e007f5035f113f9abca78fe2149c593959da5eb7
Author: John Doe <johndoe@example.com>
Date:   Tue Mar 28 00:26:53 2023 +0300

    Добавить амбиций в список дел

... # другие коммиты

```

# Статусы файлов в Git

## Статусы untracked/tracked, staged и modified

* untracked (англ. «неотслеживаемый»): новые файлы в Git-репозитории помечаются как untracked, то есть неотслеживаемые. 
* staged (англ. «подготовленный»):  После выполнения команды git add файл попадает в staging area, то есть в список файлов, которые войдут в коммит. 
* tracked (англ. «отслеживаемый»): попадают файлы, которые уже были зафиксированы с помощью git commit, а также файлы, которые были добавлены в staging area командой git add.
* modified (англ. «изменённый»): cостояние modified означает, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия.

Пример: 

1. Файл только что создали. Git ещё не отслеживает содержимое этого файла. Состояние: **untracked**.
2. Файл добавили в staging area с помощью git add. Состояние: **staged** (+ **tracked**). 
3. Возможно, изменили файл ещё раз. Состояния: **staged**, **modified** (+ **tracked**). Обрати внимание: staged и modified у одного файла, но у разных его версий.
4. Ещё раз выполнили git add. Состояние: **staged** (+ **tracked**).
5. Сделали коммит с помощью git commit. Состояние: **tracked**.
6. Изменили файл. Состояние: **modified** (+ tracked).
7. Снова добавили в staging area с помощью git add. Состояния: **staged** (+ **tracked**).
8. Сделали коммит. Состояния: **tracked**.